\documentclass[11pt,a4paper,italian]{article}

\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}	% Set document margins
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[hidelinks]{hyperref}
\usepackage{color}
\usepackage{graphicx}
\usepackage{textcomp}	% For single quotes in codes
\usepackage{indentfirst}	% For indenting first paragraph
\usepackage{pgfplots}
\usepackage{forest}
\usetikzlibrary{arrows}
\newcommand{\NA}{-}
\usepackage{ascii}

\title{\textbf{Laboratorio di Algoritmi e Strutture Dati 2020/2021} --- Seconda parte}
\date{\today}
%\author{\href{mailto:bonaccorsi.mattia@spes.uniud.it}{Mattia Bonaccorsi}, \href{mailto:kouate.muhamed@spes.uniud.it}{Muhamed Kouate}, \href{mailto:stefanel.enrico@spes.uniud.it}{Enrico Stefanel}, \href{mailto:torchanyn.andriy@spes.uniud.it}{Andriy Torchanyn}}
\author{\textbf{Mattia Bonaccorsi} --- 124610 -- \href{mailto:bonaccorsi.mattia@spes.uniud.it}{bonaccorsi.mattia@spes.uniud.it}
   \and \textbf{Muhamed Kouate} --- 137359 -- \href{mailto:kouate.muhamed@spes.uniud.it}{kouate.muhamed@spes.uniud.it}
   \and \textbf{Enrico Stefanel} --- 137411 -- \href{mailto:stefanel.enrico@spes.uniud.it}{stefanel.enrico@spes.uniud.it}
   \and \textbf{Andriy Torchanyn} --- 139535 -- \href{mailto:torchanyn.andriy@spes.uniud.it}{torchanyn.andriy@spes.uniud.it}
   }


\usepackage{listings} 
\usepackage{setspace} 


\definecolor{halfgray}{gray}{0.55}
\definecolor{snow}{RGB}{250, 250, 250}
\definecolor{green}{RGB}{0, 128, 0}
\definecolor{cyan}{RGB}{64, 128, 128}
\definecolor{folly}{rgb}{1.0, 0.0, 0.31}

\lstdefinelanguage{python}{
	morekeywords={and,assert,break,def,elif,else,for,from,global,if,import,as,in,is,lambda,not,or,pass,print,return,try,while},
	morekeywords=[2]{abs,all,any,bool,chr,dict,dir,divmod,enumerate,eval,file,filter,float,format,globals,help,id,
	input,int,len,list,locals,long,map,min,next,pow,range,input,round,set,str,sum,super,tuple,type,unichr,unicode,vars}, keywordstyle=\color{green},
	morestring=[b]", morestring=[b]', stringstyle=\color{folly}, showstringspaces=false, upquote=true,
    morecomment=[l]\#, commentstyle=\color{cyan},
    frame=single, framexleftmargin=2em, backgroundcolor=\color{snow},
    numbers=left, numberstyle=\scriptsize\color{halfgray}\ttfamily, xleftmargin=1.5em,
    inputpath=sources/,
    title=\footnotesize\ttfamily\lstname, captionpos=b,
    basicstyle=\ttfamily\small
}

\begin{document}

  \tikzset{%
    /forest,
    forest node/.style={circle split,draw, text width=1.75em, text centered,s sep+=1cm,l sep-=.5cm, font=\footnotesize},
%    forest node/.style={rectangle split,rectangle split parts=2,draw, text width=3em, text centered, l sep+=.25cm,s sep+=.25cm},
    b/.append style={draw=black, very thick},
    r/.append style={draw=red, very thick},
    nill/.append style={rectangle,draw=black, very thick, text width=1em,l sep-=2.75cm}
  }



\maketitle
\tableofcontents


\clearpage

\section{Alberi binari di ricerca semplici}

\subsection{Definizione di \textit{BST}}  
Un \textit{albero binario di ricerca} (o BST) $T$ è una struttura dati ad albero, in cui valgono le seguenti proprietà:
\begin{equation}
\begin{split}
	\forall x \in T,\; \forall y \in left(T) \rightarrow y.key < x.key	 \\
	\forall x \in T,\; \forall z \in right(T) \rightarrow z.key > x.key
\end{split}  \tag{$\star$}
\end{equation}
dove $k.key$ indica il valore della chiave di $k$, e $left(B)$ (rispettivamente $right(B)$) indica il sotto-albero sinistro (rispettivamente destro) di $B$.
\\

\textbf{Esempio} Un \textit{BST} di tipo semplice, in cui ogni nodo contiene una chiave numerica dell'insieme $\{1,2,3,4,5,6,10\}$ e un campo alfanumerico di tipo stringa, è il seguente:
\begin{center}
\begin{forest}
for tree={forest node}
	[6\nodepart{lower}six
  		[5\nodepart{lower}five
    		[1\nodepart{lower}one
				[,phantom]
				[2\nodepart{lower}two
					[,phantom]
					[4\nodepart{lower}four
						[3\nodepart{lower}three]
						[,phantom]
					]
				]
			]
    		[,phantom]
  		]
  		[10\nodepart{lower}ten]
	]
\end{forest}
\end{center}
Bisogna notare che non è l'unico \textit{BST} costruibile partendo dallo stesso insieme di chiavi. Un'alternativa, per esempio, potrebbe essere stata quella di utilizzare il valore minore come chiave per la radice dell'albero, e attaccare in ordine crescente le altre chiavi, ognuna come figlio destro del nodo precedente.

\subsection{Implementazione della struttura dati}  
\lstinputlisting[language=Python,linerange={1-64}]{bst.py} 

\subsection{Difetti dei \textit{BST}}  
Questa struttura dati ha alcuni difetti \dots



\section{Alberi binari di ricerca di tipo AVL}

\subsection{Definizione di Albero \textit{AVL}}  
Un \textit{albero AVL} $T$ è un \textit{BST} ($\star$), in cui vale la seguente proprietà:
\begin{equation}
	\forall x \in T \rightarrow | h(left(x)) - h(right(x)) | \leq 1	 \tag{$\ast$}
\end{equation}
dove $h(k)$ indica il valore dell'altezza dell'albero radicato in $k$, e $left(B)$ (rispettivamente $right(B)$) indica il sotto-albero sinistro (rispettivamente destro) di $B$.
\\

\textbf{Esempio} Un Albero \textit{AVL} in cui ogni nodo contiene una chiave numerica dell'insieme $\{1,2,3,4,5,6,9,10\}$ e un campo alfanumerico di tipo stringa, è il seguente:
\begin{center}
\begin{forest}
for tree={forest node}
	[4\nodepart{lower}four
  		[2\nodepart{lower}two
    		[1\nodepart{lower}one]
    		[3\nodepart{lower}three]
  		]
  		[6\nodepart{lower}six
    		[5\nodepart{lower}five]
    		[10\nodepart{lower}ten
				[9\nodepart{lower}nine]
				[,phantom]
			]
  		]
	]
\end{forest}
\end{center},
dove, ad esempio, $left(\texttt{root})$ ha altezza 2, mentre $right(\texttt{root})$ ha altezza 3.

\subsection{Implementazione della struttura dati}  
\lstinputlisting[language=Python]{avl.py} 

\subsection{Miglioramenti degli Alberi AVL rispetto ai \textit{BST}}  
Questa struttura dati migliora alcuni aspetti dei \textit{BST} \dots



\section{Alberi binari di ricerca di tipo Red-Black}

\subsection{Definizione di \textit{RB Tree}}  
Un \textit{albero di tipo Red-Black} (o \textit{RB Tree}) $T$ è un \textit{BST} ($\star$), in cui ogni nodo ha associato un campo "colore", che può assumere valore \textit{rosso} o \textit{nero}, ed inoltre vale che:
\begin{equation}
		\forall x \in T \rightarrow h_b(left(x)) = h_b(right(x))	 \tag{$\bullet$}
\end{equation}
dove $h_b(x)$ indica l'altezza nera dell'albero radicato in $x$, ovvero il massimo numero di nodi neri lungo un possibile cammino da $x$ a una foglia.
\\

\textbf{Esempio} Un \textit{BST} di tipo Red-Black, in cui ogni nodo contiene una chiave numerica dell'insieme $\{4,5,7,8,9,11,12\}$ e un campo alfanumerico di tipo stringa, è il seguente:
\begin{center}
\begin{forest}
for tree={forest node}
      [8\nodepart{lower}eight, b
        [5\nodepart{lower}five, b
          [4\nodepart{lower}four, r
          	[, nill]
			[, nill]
          ]
          [7\nodepart{lower}seven, r
            [, nill]
			[, nill]
          ]
        ]
        [11\nodepart{lower}eleven, r,
          [9\nodepart{lower}nine, b
          	[, nill]
			[, nill]
          ]
          [12\nodepart{lower}twelve, b
          	[, nill]
			[, nill]
          ]
        ]
      ]
 \end{forest}
\end{center}

\subsection{Implementazione della struttura dati}  
\lstinputlisting[language=Python]{rbt.py} 

\end{document}
